## 算法

### 栈（Stack）——只用 pop 和 push 完成增删的“数组”

### 队列（Queue）——只用 push 和 shift 完成增删的“数组”

#### 数组中删除元素的三种方法

shift,pop,splice

#### 数组中增加元素的三种方法

unshift,push,splice

#### 数组 VS 链表

数组在内存中地址连续

链表增删时间复杂度为O(1）

链表访问性能不佳

总结：链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。



### 二叉树

- 它可以没有根结点，作为一棵空树存在
- 如果它不是空树，那么**必须由根结点、左子树和右子树组成，且左右子树都是二叉树**。

注意，**二叉树不能被简单定义为每个结点的度都是2的树**。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。

#### 二叉树的遍历

- 左子树一定先于右子树遍历
- 所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。

#### 递归函数编写要点

- 递归式
- 递归边界

#### 算法的时间复杂度

排序: O(1) < O(logn)<O(n)<O(nlogn)<O(n^2)<O(2^n)